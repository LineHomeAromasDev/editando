<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fabric.js Canvas Example</title>
    <!-- Use the latest Fabric.js version from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>

        body {

        }
        /* Base styles for geniusBar */
        .genius-bar {
            display: flex;
            justify-content: space-evenly;

            background-color: #333;
            color: white;
            padding: 10px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 9;
        }

        #canvasContainer {
            position: absolute;
            top:0;
            left:0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas{
            box-shadow: 0px 5px 10px rgba(0,0,0,0.05);
            margin:auto;
        }
    
        .genius-bar button {
            padding: 0;
            background: #444;
            color: white;
            border: none;
            cursor: pointer;
            width:fit-content;
        }
    
        /* Elements menu hidden by default */
        .elements-menu {
            display: none;
            background-color: #555;
            position: absolute;
            top: 100px;
            left: 0;
            padding: 10px;
        }
    
        .elements-menu button {
            display: block;
            margin: 5px 0;
            background-color: #666;
            padding: 8px;
        }
    
        /* Styles for mobile: Make geniusBar vertical */
        @media (max-width: 768px) {
            .genius-bar {
                flex-direction: column;
                position: fixed;
                left: 0;
                right: 0;
                top: 0;
            }
    
            .elements-menu {
                left: 0;
                right: 0;
                top: 50px;
            }
        }


    .color-picker {
        display: flex;
        flex-direction: column;
        background-color: #444;
        color: white;
        padding: 10px;
        position: absolute;
        top: 100px;
        z-index:10;
    }

    #fillColorPicker { left: 0; }
    #strokeColorPicker { left: 150px; }
    </style>
    
</head>
<body>
    
    <div id="geniusBar" class="genius-bar">
        <!-- Button to toggle the color/gradient picker -->
        <button id="toggleFillColor">Fill Color/Gradient</button>
        <button id="toggleStrokeColor">Stroke Color</button>
        <div id="fillColorPicker" class="color-picker" style="display: none;">
            <label for="fillSolidColor">Solid Color:</label>
            <input type="color" id="fillSolidColor">
            <button id="applyGradient">Apply Gradient</button>
        </div>
        <div id="strokeColorPicker" class="color-picker" style="display: none;">
            <label for="strokeSolidColor">Solid Stroke Color:</label>
            <input type="color" id="strokeSolidColor">
        </div>
    </div>
    
    
    <div id="canvasContainer">
        <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <script>
        // Initialize the canvas
        const canvas = new fabric.Canvas('canvas', {
            selection: true,
            backgroundColor: 'white',
        });

        
        // Sample object to test zoom, pan, and rotate
        const rect = new fabric.Rect({
            left: 100,
            top: 100,
            fill: 'red',
            width: 100,
            height: 100,
            angle: 0,
            strokeWidth: 0, // Make the stroke width 0 to eliminate border spacing
        });
        canvas.add(rect);

        // Canvas and container setup
const canvasContainer = document.getElementById('canvasContainer');

// Initial transform properties
let currentZoom = 1;
let panX = 0;
let panY = 0;
let isPanning = false;
let startPanPoint = { x: 0, y: 0 };

// Utility function to update transform style on canvasContainer
function updateTransform() {
    canvasContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
}

// Handle Zooming with Mouse Wheel (Desktop) or Gesture (Mobile)
function zoomCanvas(e) {
    e.preventDefault();

    // Determine zoom direction
    const zoomDirection = e.deltaY < 0 || (e.scale && e.scale > 1) ? 1 : -1;
    const zoomStep = 0.1;

    // Update zoom level
    currentZoom += zoomStep * zoomDirection;
    currentZoom = Math.max(0.5, Math.min(3, currentZoom)); // Zoom limits (min: 0.5, max: 3)

    updateTransform();
}

// Add desktop and mobile zoom listeners
canvasContainer.addEventListener('wheel', zoomCanvas); // Desktop
canvasContainer.addEventListener('gesturechange', zoomCanvas); // Mobile (Pinch)

// Start Pan (Mouse or Touch)
function startPan(e) {
    // Only start panning if not touching an object
    const isOverObject = canvas.getActiveObject() || canvas.findTarget(e);
    if (!isOverObject) {
        isPanning = true;
        startPanPoint = {
            x: e.clientX || e.touches[0].clientX,
            y: e.clientY || e.touches[0].clientY
        };
    }
}

// Pan Canvas (Mouse or Touch Move)
function panCanvas(e) {
    if (!isPanning) return;

    const currentPoint = {
        x: e.clientX || e.touches[0].clientX,
        y: e.clientY || e.touches[0].clientY
    };

    // Calculate pan movement
    const dx = currentPoint.x - startPanPoint.x;
    const dy = currentPoint.y - startPanPoint.y;

    // Update pan coordinates
    panX += dx;
    panY += dy;

    updateTransform();

    // Update start point for next movement
    startPanPoint = currentPoint;
}

// End Pan (Mouse or Touch End)
function endPan() {
    isPanning = false;
}

// Event listeners for desktop and mobile pan functionality
canvasContainer.addEventListener('mousedown', startPan);
canvasContainer.addEventListener('mousemove', panCanvas);
canvasContainer.addEventListener('mouseup', endPan);
canvasContainer.addEventListener('mouseleave', endPan); // Ensure panning stops if mouse leaves the canvas

// Touch support for mobile panning
canvasContainer.addEventListener('touchstart', startPan);
canvasContainer.addEventListener('touchmove', panCanvas);
canvasContainer.addEventListener('touchend', endPan);

        // Adjust canvas size
        canvas.setWidth(window.innerWidth * 0.8);
        canvas.setHeight(window.innerHeight * 0.8);









    // Get elements
    const elementsBtn = document.getElementById('elementsBtn');
    const elementsMenu = document.getElementById('elementsMenu');
    const shapeBtns = document.querySelectorAll('.shapeBtn');

    // Toggle elements menu
    elementsBtn.addEventListener('click', function() {
        const isVisible = elementsMenu.style.display === 'block';
        elementsMenu.style.display = isVisible ? 'none' : 'block';
    });

    const closeMenu = () => {
        elementsMenu.style.display = 'none';
    };

    shapeBtns.forEach(button => {
        button.addEventListener('click', function() {
            const shapeType = button.dataset.shape;
            let shape;
            switch (shapeType) {
                case 'rect':
                    shape = new fabric.Rect({ left: 100, top: 100, fill: 'blue', width: 100, height: 100 });
                    break;
                case 'circle':
                    shape = new fabric.Circle({ left: 100, top: 100, fill: 'green', radius: 50 });
                    break;
                case 'triangle':
                    shape = new fabric.Triangle({ left: 100, top: 100, fill: 'red', width: 100, height: 100 });
                    break;
                default:
                    break;
            }
            if (shape) {
                canvas.add(shape);
                canvas.renderAll();
                closeMenu();  // Close menu after shape is added
            }
        });
    });







    const fillColorPicker = document.getElementById('fillColorPicker');
    const strokeColorPicker = document.getElementById('strokeColorPicker');
    const toggleFillColor = document.getElementById('toggleFillColor');
    const toggleStrokeColor = document.getElementById('toggleStrokeColor');
    const fillSolidColor = document.getElementById('fillSolidColor');
    const strokeSolidColor = document.getElementById('strokeSolidColor');
    const applyGradient = document.getElementById('applyGradient');

    // Toggle visibility of the fill color picker
    toggleFillColor.addEventListener('click', () => {
        fillColorPicker.style.display = fillColorPicker.style.display === 'none' ? 'block' : 'none';
    });

    // Toggle visibility of the stroke color picker
    toggleStrokeColor.addEventListener('click', () => {
        strokeColorPicker.style.display = strokeColorPicker.style.display === 'none' ? 'block' : 'none';
    });

    // Apply solid fill color or background color if no item is selected
    fillSolidColor.addEventListener('input', function() {
        const color = fillSolidColor.value;
        const activeObject = canvas.getActiveObject();

        if (activeObject) {
            if (activeObject.type === 'group') {
                activeObject.forEachObject(obj => obj.set('fill', color));
            } else {
                activeObject.set('fill', color);
            }
        } else {
            canvas.setBackgroundColor(color, canvas.renderAll.bind(canvas));
        }
        canvas.renderAll();
    });

    // Apply solid stroke color
    strokeSolidColor.addEventListener('input', function() {
        const color = strokeSolidColor.value;
        const activeObject = canvas.getActiveObject();

        if (activeObject) {
            if (activeObject.type === 'group') {
                activeObject.forEachObject(obj => obj.set('stroke', color));
            } else {
                activeObject.set('stroke', color);
            }
        }
        canvas.renderAll();
    });

    // Apply a gradient fill to the selected object or background
    applyGradient.addEventListener('click', () => {
        const activeObject = canvas.getActiveObject();

        const gradient = new fabric.Gradient({
            type: 'linear',
            coords: { x1: 0, y1: 0, x2: 0, y2: 1 },
            colorStops: [
                { offset: 0, color: '#ff0' },
                { offset: 1, color: '#f00' }
            ]
        });

        if (activeObject) {
            activeObject.set('fill', gradient);
        } else {
            canvas.setBackgroundColor(gradient, canvas.renderAll.bind(canvas));
        }
        canvas.renderAll();
    });
    

    </script>
</body>
</html>
